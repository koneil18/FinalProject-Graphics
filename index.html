<!-- 
        CSC3210 Final Project
        Authors: Kathryn O'Neil, Jared Rathbun, Garald Seip

        This file [...]

        For above and beynd, we [...]
    -->
<html>
<head>
    <title>Attic Checkers</title>
    <link rel="stylesheet" href="./index.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script type="importmap">
        {
            "imports": {
                "three": "./lib/three.js-master/build/three.module.js",
                "OrbitControls": "./lib/three.js-master/examples/jsm/controls/OrbitControls.js"
            }
        }
    </script>
    <script>
        const playGameClick = (evt) => {
            evt.preventDefault();
            document.getElementById('preGamePopUp').remove();
        }
    </script>
</head>
<body id="body">
    <div id="preGamePopUp" class="fullScreenPopUp">
        <button class="playGameBtn" onclick="playGameClick(event)">Play Game</button>
    </div>
    <canvas id = "myCanvas" width = window.innerWidth height = window.innerHeight style="z-index: 1; position: absolute; top: 0; left: 0;"></canvas>
    <script src="./lib/tween.umd.js"></script>
    <script type = "module">
        import * as THREE from 'three';
        import { OrbitControls } from 'OrbitControls';
        import { GameBoard } from './dao.js';
        import { ParticleSimulator, BurstHandler } from './dust.js';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window
            .innerWidth / window.innerHeight, .1, 3000);
        camera.position.set(0, 5, 5);
        camera.lookAt(new THREE.Vector3(0, 0, 0));
        scene.add(camera);

        const renderer = new THREE.WebGLRenderer({
            canvas: myCanvas, antialias: true
        });
        renderer.setClearColor(0x000000);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;

        const color = 0xFFFFFF;
        const intensity = 1;
        const light = new THREE.AmbientLight(color, intensity);
        scene.add(light);

        const atticDimensions = new THREE.Box3(new THREE.Vector3(-25, -10, -25), 
            new THREE.Vector3(25, 10, 25));
        const bh = new BurstHandler();

        // This needs to be disabled to make MouseClicking work.
        //new OrbitControls(camera, renderer.domElement);

        const rayCaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const gameBoard = new GameBoard(scene, camera, bh);

        // Found at: https://threejs.org/docs/#api/en/core/Raycaster
        document.addEventListener('mousedown', (event) => {
            // calculate pointer position in normalized device coordinates
            // (-1 to +1) for both components
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
            rayCaster.setFromCamera(pointer, camera);
            const intersects = rayCaster.intersectObjects(gameBoard
                .getTilesArray());

            if (intersects.length > 0) {
                var clickPosition = intersects[0].object.position;
                gameBoard.handleClick(clickPosition);
            }
        });

        function keyHandler(e)
        {
            var key = e.key.toLowerCase();
            switch(key)
            {
                // N case advances the fractal.
                case "n":
                    bh.add(new THREE.Vector3(-2.5, 0, -2.5));
                    break;
            }
        };
        
        document.addEventListener("keydown", keyHandler, false);

        var prevTime, time, delta;

        function render(time) {
            time = performance.now();
            delta = (time - prevTime) / 1000;

            TWEEN.update(time);
            bh.update();
            ps.update(delta);
            renderer.render(scene, camera);
            requestAnimationFrame(render);

            prevTime = time;
        }

        const ps = new ParticleSimulator(scene, atticDimensions, gameBoard
            .allObjects, bh);
        prevTime = performance.now();

        render();
    </script>
</body>
</html>